	// buffer := make([]byte, 1024)
	// if _, err := connection.Read(buffer); err != nil {
	// 	if err == io.EOF {
	// 		log.Println(name, " has left !")
	// 	}
	// }

	// connection.Write([]byte(greeting()))
	// connection.Close()

	/*clients[connection.RemoteAddr().String()] = connection

	messages <- newMessage("joined.", connection)

	input := bufio.NewScanner(connection)
	for input.Scan() {
		messages <- newMessage(": "+input.Text(), connection)
	}

	delete(clients, connection.RemoteAddr().String())

	leaving <- newMessage("has left.", connection)

	connection.Close()*/

	// clean Up All things
	sigs := make(chan os.Signal, 1)
	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		<-sigs
		cleanupAllTheThings()
		os.Exit(0)
	}()

	// fmt.Println(*group)
	// if key == name {
	// 	return true
	// } else {
	// 	Write([]byte(message))
	// return true

	// })
	// for {
	// 	select {
	// 	case msg := <-messages:
	// 		for _, connect := range clients {
	// 			if msg.address == connect.RemoteAddr().String() {
	// 				continue
	// 			}
	// 			fmt.Fprintln(connect, msg.text)
	// 		}
	// 	case msg := <-leaving:
	// 		for _, connect := range clients {
	// 			fmt.Fprintln(connect, msg.text)
	// 		}
	// 	}
	// }
	// }

	/*func leaveMessage(connect net.Conn, key, value interface{}, name string) {

	  }*/